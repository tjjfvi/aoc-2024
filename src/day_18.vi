
use std::{option::Option::{Option, Some, None}, array::Array};

// const config: (N32, N32) = (7, 12);
const config: (N32, N32) = (71, 1024);

pub fn main(&io: &IO) {
  let (size, iters) = config;

  let grid = Array::new(size, Array::new(size, -1));

  let i = 0;
  while io.read_line() is Some(line) {
    let (x, y) = line.split_once(",");
    let x = N32::parse(x).unwrap();
    let y = N32::parse(y.unwrap()).unwrap();
    *(*grid.get(y)).get(x) = i;
    i += 1;
  }

  let bytes = i;

  dyn fn show_grid(c: N32) {
    io.println(grid.to_list().map(fn(row: Array[N32]) {
      row.fold_front(
        "",
        fn(s: String, n: N32) {
          s ++ if n < c {
            "#"
          } else {
            "."
          }
        },
      )
    }).join("\n"))
  }

  // show_grid(iters);

  show_grid(-1);

  let orig_grid = grid;

  let part1 = pathfind(grid, size, iters);

  io.println("Part 1: " ++ part1.to_string());

  let part2 = 0;

  let i = iters;
  while i <= bytes {
    if pathfind(grid, size, i) != 0 {
      io.println(i.to_string());
    }
    i += 1;
  }

  io.println("Part 2: " ++ part2.to_string());
}

fn pathfind(grid: Array[Array[N32]], size: N32, iters: N32) -> N32 {
  let cur = [(0, 0)];

  let result = 0;

  let i = 0;
  while cur.len() != 0 {
    let next = [];
    while cur.pop_front() is Some(pos) {
      let (x, y) = pos;
      if x == size - 1 && y == size - 1 {
        result = i;
        next = [];
        break;
      }
      let &cell = (*grid.get(y)).get(x);
      if cell >= iters {
        cell = 0;
        dyn fn visit((x, y): (N32, N32)) {
          if x < size && y < size && *(*grid.get(y)).get(x) >= iters {
            next ++= [(x, y)];
          }
        }
        visit(pos + (1, 0));
        visit(pos + (0, 1));
        visit(pos + (-1, 0));
        visit(pos + (0, -1));
      }
    }
    cur = next;
    i += 1;
  }

  result
}
